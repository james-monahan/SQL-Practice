DATETIME:

SHOW (keyword) DateStyle;
SET DateStyle='ISO, MDY';

KEYWORDS
SELECT current_date;
SELECT now() AT TIME ZONE 'EST';
EXTRACT(year / month / day FROM col)
EXTRACT(dow / week / quarter FROM col)
#ROUND VALUE AS FLOOR
SELECT NOW(), DATE_TRUNC('month', NOW()); use in groupby 
SELECT INTERVAL '5 days';
SELECT TIMESTAMP '2016-03-01 00:00:00' + INTERVAL '7 days' AS new_date; (other math operations too)
SELECT DATE '2016-03-01' + 7 AS new_date; (timesamp more precise)


Latitude and Longitude:
(install)
CREATE EXTENSION cube;
CREATE EXTENSION earthdistance;

SELECT point(longitude, latitude)
( longitude first and then latitude ) like (x, y)

SELECT point(-90, 38) <@> point(-91, 37) AS distance_in_miles;

SELECT
    AVG(distance) AS avg_dist,
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY distance) 
    AS median_dist
FROM closest_dealerships;


ARRAYS:
SELECT ARRAY['Lemon', 'Bat Limited Edition'] AS example_purchased_products;
#put all unique into an array
SELECT product_type, ARRAY_AGG(DISTINCT model) AS models FROM products GROUP BY 1;
SELECT product_type, ARRAY_AGG(model ORDER BY year) AS models FROM products GROUP BY 1;
SELECT UNNEST(ARRAY[123, 456, 789]) AS example_ids;
SELECT STRING_TO_ARRAY('hello there how are you?', ' ');
#concat array of strings
SELECT ARRAY_TO_STRING(ARRAY['Lemon', 'Bat Limited Edition'], ', ')  AS example_purchased_products;
concatenate - array_cat()
append to array_append(array, val)
ISIN 3 = ANY(ARRAY[1,21]) return false
&& checks overlap, @> check if contains
EXAMPLE
SELECT
  super_email_seq.id AS superset_id,
  sub_email_seq.id AS subset_id
FROM top_email_sequences AS super_email_seq
CROSS JOIN top_email_sequences AS sub_email_seq
WHERE super_email_seq.email_sequence @> sub_email_seq.email_sequence
AND super_email_seq.id != sub_email_seq.id;

JSON:
SELECT row_to_json(c, TRUE) FROM customers c limit 1;

SELECT
    '{
         "a": 1,
         "b": 2,
         "c": 3
     }'::JSON -> 'b' AS data;
#value / element in list / value
SELECT
    '{
         "a": 1,
         "b": [
             {"d": 4},
             {"d": 6},
             {"d": 4}
    ],
         "c": 3
     }'::JSON #> ARRAY['b', '1', 'd'] AS data;
     
select jsonb_insert('{"a":1,"b":"foo"}', ARRAY['c'], '2');
select JSONB_ARRAY_ELEMENTS(customer_json -> 'sales') AS sale_json

TEXT ANALYTICS:
SELECT STRING_TO_ARRAY('Danny and Matt are friends.', ' ');
#'g' flag means global
SELECT REGEXP_REPLACE('Danny and Matt are friends.', '[!,.?-]', ' ', 'g');
#stemming
SELECT TS_LEXIZE('english_stem', 'running');
#use UNNEST to parse into individual words
SELECT UNNEST(STRING_TO_ARRAY(feedback, ' ')) AS word, rating FROM customer_survey limit 10;
#combine
SELECT
    (TS_LEXIZE('english_stem',UNNEST(STRING_TO_ARRAY(
     REGEXP_REPLACE(feedback, '[^a-zA-Z]+', ' ', 'g'),' ')  )))[1] AS token,
#case insensitive
SELECT * FROM customer_survey WHERE feedback ILIKE '%pop%';

#over entire document, removes stop words
SELECT
    feedback,
    to_tsvector('english', feedback) AS tsvectorized_feedback
FROM table

SELECT to_tsquery('english', 'lemon & scooter');
#to_tsquery accepts Boolean syntax, such as | for or and & for and. It also accepts ! for not.

SELECT plainto_tsquery('english', 'lemon') && plainto_tsquery('english', 'bat') || plainto_tsquery('english', 'chi');
The && operator will produce a query that requires the left query and the right query, while the || operator will produce a query that matches either the left or the right tsquery object

We can query a ts_vector object using a ts_query object using the @@ operator.
SELECT * FROM _
WHERE to_tsvector('english', feedback) @@ plainto_tsquery('english', 'lemon scooter');

#Materialized view to precomput the vectors for more efficent querying
CREATE MATERIALIZED VIEW customer_survey_search AS (
    SELECT
        rating,
        feedback,
        to_tsvector('english', feedback)
            || to_tsvector('english', rating::text) AS searchable
    FROM customer_survey
);
